# System-Level Text-to-Speech Service Design

## Summary

SysTTS is a Windows application that provides system-level text-to-speech capabilities using neural voice models. It runs as a user-session application with a system tray icon and accepts speech requests through three input modes: an HTTP API for programmatic integration (e.g., web apps sending notifications), global hotkeys that speak selected text using preconfigured voices, and global hotkeys that present a voice picker popup before speaking. The service uses Sherpa-ONNX to run Piper TTS voice models, which are loaded from a `voices/` directory and swapped via configuration files — adding a new voice requires only dropping ONNX files into the directory and updating JSON config.

The architecture mirrors the existing whisper-service dictation tool: a WinForms application built on `Host.CreateApplicationBuilder` with dependency injection, a system tray presence via `NotifyIcon`, Win32 global keyboard hooks, and an embedded Kestrel HTTP server bound to localhost. Speech requests are processed through a priority queue that ensures serial playback (one utterance at a time), with configurable interrupt behavior for higher-priority sources. Per-source configuration allows different applications to use different voices and apply regex filters to control what text gets spoken. The first integration is T-Tracker (transit notification app), which will send notification text to the service's HTTP endpoint, with a Stream Deck plugin as a secondary use case.

## Definition of Done

A Windows service with tray icon that speaks text aloud using Piper TTS with configurable ONNX voice models. The service accepts text via three input modes: (1) an HTTP POST endpoint for programmatic use by apps like T-Tracker, with per-source voice and filter rules; (2) global hotkeys that read selected text with a preconfigured voice; and (3) global hotkeys that read selected text after presenting a voice picker popup. Voice models are swapped via config files — no recompilation. The project ships with pre-built Piper voices and documents the external workflow for importing custom-trained ONNX models.

**Success criteria:**
- Service runs as Windows service with system tray presence
- HTTP endpoint accepts text, applies per-source voice/filter config, and speaks
- Global hotkeys capture selected text (via clipboard) and speak with configured or user-selected voice
- Voice models load from a `voices/` directory based on config — adding a new voice requires only dropping in an ONNX file and updating config
- T-Tracker sends notification text to the service as the first integration

**Out of scope for v1:**
- Custom voice model training pipeline (documented externally only)
- Clipboard monitor mode (passive speak-on-copy)
- Windows notification listener interception

## Acceptance Criteria

### sys-tts.AC1: Service runs as Windows application with system tray presence
- **sys-tts.AC1.1 Success:** Application starts, tray icon appears in system tray, and `GET /api/status` returns 200 with `{ running: true }`
- **sys-tts.AC1.2 Success:** Right-clicking tray icon shows context menu with status info and quit option
- **sys-tts.AC1.3 Success:** Selecting "Quit" from tray menu shuts down Kestrel, unhooks hotkeys, and exits cleanly (no orphan processes)
- **sys-tts.AC1.4 Failure:** If configured port is already in use, application logs error and exits with descriptive message (does not crash silently)

### sys-tts.AC2: HTTP endpoint accepts text, applies per-source voice/filter config, and speaks
- **sys-tts.AC2.1 Success:** `POST /api/speak` with `{ text, source }` resolves voice from source config and produces audible speech
- **sys-tts.AC2.2 Success:** `POST /api/speak` with explicit `voice` field overrides the source-configured voice
- **sys-tts.AC2.3 Success:** `POST /api/speak` with source that has regex filters silently drops text that matches no filter (returns 202, no speech)
- **sys-tts.AC2.4 Success:** `POST /api/speak` with source that has `filters: null` speaks all text regardless of content
- **sys-tts.AC2.5 Success:** `POST /api/stop` cancels current speech and clears the queue
- **sys-tts.AC2.6 Failure:** `POST /api/speak` with missing `text` field returns 400 error
- **sys-tts.AC2.7 Edge:** Higher-priority request interrupts lower-priority speech currently playing (when `InterruptOnHigherPriority` is true)
- **sys-tts.AC2.8 Edge:** Queue at max depth drops oldest low-priority item when new request arrives

### sys-tts.AC3: Global hotkeys capture selected text and speak with configured or user-selected voice
- **sys-tts.AC3.1 Success:** Pressing a direct-mode hotkey with text selected in any application speaks that text with the hotkey's configured voice
- **sys-tts.AC3.2 Success:** Pressing a picker-mode hotkey with text selected shows voice picker popup near cursor with available voices
- **sys-tts.AC3.3 Success:** Selecting a voice in the picker speaks the captured text with that voice
- **sys-tts.AC3.4 Success:** Clipboard contents are preserved after hotkey capture (saved before, restored after)
- **sys-tts.AC3.5 Success:** Last-used voice in picker mode is remembered across sessions
- **sys-tts.AC3.6 Success:** Picker popup dismisses on Escape, click-away, or voice selection without side effects
- **sys-tts.AC3.7 Failure:** Hotkey pressed with no text selected (empty clipboard after Ctrl+C) does nothing (no error, no speech)
- **sys-tts.AC3.8 Success:** `POST /api/speak-selection` performs clipboard capture in the service and speaks with specified or default voice

### sys-tts.AC4: Voice models load from voices/ directory — adding a voice requires only dropping in an ONNX file and updating config
- **sys-tts.AC4.1 Success:** `GET /api/voices` returns list of all `.onnx` + `.onnx.json` pairs found in `voices/` directory
- **sys-tts.AC4.2 Success:** Dropping a new ONNX model pair into `voices/` while running makes it available without restart (FileSystemWatcher)
- **sys-tts.AC4.3 Success:** Voice models are loaded lazily on first use and cached in memory for subsequent requests
- **sys-tts.AC4.4 Failure:** Source config referencing a missing voice falls back to `DefaultVoice` with a logged warning
- **sys-tts.AC4.5 Edge:** `voices/` directory with zero valid models — service starts, endpoints return empty list, speak requests log error

### sys-tts.AC5: T-Tracker sends notification text to the service as the first integration
- **sys-tts.AC5.1 Success:** T-Tracker's notification code includes fire-and-forget `fetch()` to `POST /api/speak` with `source: 't-tracker'`
- **sys-tts.AC5.2 Success:** T-Tracker functions normally when SysTTS service is not running (`.catch(() => {})` pattern)
- **sys-tts.AC5.3 Edge:** SysTTS applies t-tracker source filters — only text matching configured patterns (e.g., "approaching", "arrived") produces speech

### sys-tts.AC6: Cross-Cutting Behaviors
- **sys-tts.AC6.1:** Speech queue processes requests serially — no audio collision from concurrent requests
- **sys-tts.AC6.2:** Kestrel bound to `127.0.0.1` only — no external network access, no firewall prompt
- **sys-tts.AC6.3:** Stream Deck plugin populates voice dropdown from `GET /api/voices` and triggers speech via HTTP endpoints

## Glossary

- **Piper TTS**: An open-source neural text-to-speech system that uses ONNX models to convert text to speech with natural-sounding voices
- **ONNX**: Open Neural Network Exchange — a standard format for machine learning models that allows trained models to run on different frameworks
- **Sherpa-ONNX**: A cross-platform library for running ONNX-based speech models (ASR, TTS) with minimal dependencies
- **Kestrel**: Microsoft's cross-platform web server for ASP.NET Core applications, embedded here to provide an HTTP API within a WinForms app
- **NAudio**: .NET library for working with audio devices and processing audio streams
- **WinForms**: Windows Forms — Microsoft's traditional UI framework for building Windows desktop applications
- **NotifyIcon**: WinForms component that creates an icon in the Windows system tray with context menu support
- **Dependency Injection (DI)**: Design pattern where services are provided to classes rather than created internally, managed by `Microsoft.Extensions.DependencyInjection`
- **BackgroundService**: Base class from `Microsoft.Extensions.Hosting` for long-running background operations in a hosted application
- **Win32 keyboard hooks**: Low-level Windows API mechanism (`SetWindowsHookEx`) to intercept keyboard events globally across all applications
- **STA thread**: Single-Threaded Apartment — a COM threading model required for Windows clipboard operations
- **FileSystemWatcher**: .NET component that monitors file system changes (create, delete, modify) in a directory
- **Fire-and-forget**: HTTP request pattern where the client sends a request but doesn't wait for a response or handle errors
- **Stream Deck**: Elgato hardware device with programmable LCD buttons, supports custom plugins for triggering actions
- **Session 0**: Windows session where system services run; user applications run in Session 1+ where audio/UI work normally
- **JSON:API**: A specification for building APIs in JSON (used by MBTA in T-Tracker)
- **T-Tracker**: Patrick's MBTA real-time transit tracking web app (pure ES6 modules, Leaflet maps, SSE connection to MBTA API)
- **whisper-service**: Patrick's existing dictation tool that uses Whisper.net for speech recognition; architectural template for SysTTS
- **GPT-SoVITS**: Third-party tool for training custom TTS voices (mentioned for custom voice workflow documentation)

## Architecture

Single-process WinForms application running in user session (not Session 0). Mirrors the architecture of the existing whisper-service dictation tool: `Host.CreateApplicationBuilder` with DI container, `BackgroundService`-derived worker, system tray via `NotifyIcon`, and Win32 keyboard hooks for global hotkeys.

### Core Components

```
┌──────────────────────────────────────────────────┐
│              SysTTS (WinForms App)                │
│                                                  │
│  ┌───────────┐  ┌────────────┐  ┌─────────────┐ │
│  │ Kestrel   │  │ Hotkey     │  │ Tray Icon   │ │
│  │ HTTP API  │  │ Service    │  │ Service     │ │
│  └─────┬─────┘  └─────┬──────┘  └──────┬──────┘ │
│        │               │               │        │
│        ▼               ▼               │        │
│  ┌───────────────────────────────┐      │        │
│  │       Speech Queue            │      │        │
│  │  (prioritized, serial)        │      │        │
│  └──────────────┬────────────────┘      │        │
│                 ▼                       │        │
│  ┌───────────────────────────────┐      │        │
│  │   TTS Engine (Sherpa-ONNX)    │◄─────┘        │
│  │   + Voice Manager             │               │
│  └──────────────┬────────────────┘               │
│                 ▼                                │
│  ┌───────────────────────────────┐               │
│  │   Audio Output (NAudio)       │               │
│  │   WaveOutEvent                │               │
│  └───────────────────────────────┘               │
└──────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────┐
│         Stream Deck Plugin (separate)            │
│   Calls HTTP API on localhost:PORT               │
└──────────────────────────────────────────────────┘
```

### Data Flow

**HTTP mode (programmatic):**
App POSTs `{ text, source }` to `/api/speak` → Kestrel routes to SpeechQueue → Queue resolves voice from per-source config → Sherpa-ONNX synthesizes audio → NAudio plays through default audio device.

**Hotkey direct mode (ad-hoc, preconfigured voice):**
User selects text → presses hotkey → HotkeyService saves clipboard, simulates Ctrl+C, reads clipboard, restores clipboard → text sent to SpeechQueue with configured voice → synthesize → play.

**Hotkey picker mode (ad-hoc, user-selected voice):**
Same as direct mode, but after clipboard capture a WinForms popup appears near cursor showing available voices (last-used pre-selected). User clicks a voice → text sent to SpeechQueue → synthesize → play.

**Stream Deck:**
Button press → plugin POSTs to `/api/speak-selection` with voice ID → service performs clipboard capture internally → SpeechQueue → synthesize → play.

### HTTP API Contract

```
POST /api/speak
  Request:  { "text": string, "source"?: string, "voice"?: string }
  Response: 202 { "queued": true, "id": string }
  Behavior: If source provided, applies per-source voice/filter config.
            If voice provided, overrides source config.
            If text doesn't match source filters, silently drops (returns 202).

POST /api/speak-selection
  Request:  { "voice"?: string }
  Response: 202 { "queued": true, "id": string, "text": string }
  Behavior: Service captures selected text via clipboard internally.
            If voice omitted, uses default voice.

GET /api/voices
  Response: 200 [{ "id": string, "name": string, "sampleRate": number }, ...]
  Behavior: Returns all voices found in voices/ directory.

GET /api/status
  Response: 200 { "running": true, "activeVoices": number, "queueDepth": number }

POST /api/stop
  Response: 200 { "stopped": true }
  Behavior: Cancels current speech, clears queue.
```

### Configuration Contract

```json
{
  "Service": {
    "Port": 5100,
    "VoicesPath": "voices",
    "DefaultVoice": "en_US-amy-medium",
    "MaxQueueDepth": 10,
    "InterruptOnHigherPriority": true
  },
  "Sources": {
    "t-tracker": {
      "voice": "custom-bear",
      "filters": ["approaching", "arrived"],
      "priority": 1
    },
    "default": {
      "voice": "en_US-amy-medium",
      "filters": null,
      "priority": 3
    }
  },
  "Hotkeys": [
    { "key": "F23", "mode": "direct", "voice": "en_US-amy-medium" },
    { "key": "F22", "mode": "picker" }
  ],
  "Audio": {
    "OutputDevice": null,
    "Volume": 1.0
  }
}
```

### Speech Queue Behavior

Requests are processed serially — one utterance at a time. Priority ordering: lower number = higher priority. If `InterruptOnHigherPriority` is true, a higher-priority request cancels the current speech. Queue has a max depth; oldest low-priority items are dropped when full.

### Voice Manager

On startup, scans `voices/` directory for `.onnx` + `.onnx.json` file pairs. Models are loaded lazily on first use and cached in memory. A `FileSystemWatcher` monitors the directory — new models become available without restart. If a source config references a missing voice, falls back to `DefaultVoice` with a logged warning.

**Adding a custom voice:**
1. Train model externally (GPT-SoVITS, Piper fine-tuning)
2. Export as ONNX + JSON config
3. Drop files into `voices/` directory
4. Update `appsettings.json` source mappings to reference new voice ID
5. Model detected automatically; config changes require restart

### Stream Deck Plugin

Standalone JavaScript plugin (Stream Deck SDK 6.x). Three button actions:

1. **Speak Selected Text** — POSTs to `/api/speak-selection` with configured voice
2. **Speak Custom Text** — POSTs static text to `/api/speak` (configurable in button settings)
3. **Stop Speaking** — POSTs to `/api/stop`

Plugin settings populated dynamically from `GET /api/voices`. No C# in the plugin — it is a thin HTTP client.

### T-Tracker Integration Contract

T-Tracker adds a `fetch()` call alongside its existing `new Notification()` in `notifications.js`:

```javascript
fetch('http://localhost:5100/api/speak', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
        text: `${vehicleTypeLabel} approaching ${checkpointName}`,
        source: 't-tracker'
    })
}).catch(() => {});
```

Fire-and-forget. T-Tracker does not depend on SysTTS being available. Implementation deferred to a separate T-Tracker PR.

## Existing Patterns

This design mirrors the whisper-service (`C:\Users\patri\Documents\claudeProjects\projects\whisper-service\`) architecture:

- **Project type:** `net8.0-windows` with `WinExe` output, `UseWindowsForms` enabled
- **Hosting:** `Host.CreateApplicationBuilder` + `Microsoft.Extensions.Hosting.WindowsServices`
- **DI registration:** Singleton services, one `BackgroundService`-derived hosted service
- **Main thread:** `TrayApplicationContext` subclass of `ApplicationContext`, `Application.Run()` for WinForms message pump
- **Tray icon:** `System.Windows.Forms.NotifyIcon` with `ContextMenuStrip`, dynamic icon bitmaps
- **Global hotkeys:** Win32 `SetWindowsHookEx` with `WH_KEYBOARD_LL`, virtual key code parsing from config strings
- **Configuration:** Strongly-typed `IOptions<T>` classes bound in `Program.cs`, `appsettings.json` as source
- **Threading:** Hotkey events on main thread, heavy work (synthesis) dispatched via `Task.Run`
- **Clipboard access:** STA thread for `System.Windows.Forms.Clipboard` operations

**New patterns (not in whisper-service):**

- **Embedded Kestrel HTTP server** — whisper-service has no HTTP endpoint. SysTTS uses `WebApplication.CreateBuilder` merged with the existing host, bound to `localhost:PORT` only.
- **Sherpa-ONNX native bindings** — whisper-service uses Whisper.net (GGML). SysTTS uses `org.k2fsa.sherpa.onnx` NuGet package for TTS with Piper ONNX models.
- **Speech queue** — whisper-service processes one recording at a time (implicit serialization). SysTTS needs an explicit priority queue for multiple input sources.
- **FileSystemWatcher for hot-reload** — whisper-service loads model once at startup. SysTTS watches `voices/` for new models.

## Implementation Phases

<!-- START_PHASE_1 -->
### Phase 1: Project Scaffolding and Service Host

**Goal:** Working WinForms application with DI container, tray icon, and embedded Kestrel HTTP server responding on localhost.

**Components:**
- Solution and `.csproj` with `net8.0-windows`, `WinExe`, `UseWindowsForms`
- NuGet dependencies: `Microsoft.Extensions.Hosting`, `Microsoft.Extensions.Hosting.WindowsServices`, `H.NotifyIcon`, `NAudio`, ASP.NET Core
- `Program.cs` — host builder with merged `WebApplication` and `Application.Run()`
- `TrayApplicationContext` — `ApplicationContext` subclass, tray icon initialization
- `TrayIconService` — NotifyIcon with context menu (status, quit)
- Kestrel bound to `http://127.0.0.1:5100` with a health-check `GET /api/status` endpoint
- Strongly-typed settings classes: `ServiceSettings`, `AudioSettings`
- `appsettings.json` with initial config structure

**Dependencies:** None (first phase)

**Done when:** Application starts, tray icon appears, `GET http://localhost:5100/api/status` returns 200, application shuts down cleanly from tray menu.
<!-- END_PHASE_1 -->

<!-- START_PHASE_2 -->
### Phase 2: TTS Engine and Voice Manager

**Goal:** Sherpa-ONNX loads Piper ONNX voice models and synthesizes text to audio bytes.

**Components:**
- NuGet dependencies: `org.k2fsa.sherpa.onnx`, `org.k2fsa.sherpa.onnx.runtime.win-x64`
- `VoiceManager` service — scans `voices/` directory, catalogs available models, lazy-loads and caches Sherpa-ONNX TTS instances, `FileSystemWatcher` for hot-reload
- `TtsEngine` service — accepts text + voice ID, resolves model via VoiceManager, synthesizes to PCM audio bytes via Sherpa-ONNX
- `AudioPlayer` service — plays PCM bytes via NAudio `WaveOutEvent`, supports cancel
- Strongly-typed settings: `VoiceSettings` (voices path, default voice)
- `GET /api/voices` endpoint returning catalog from VoiceManager
- At least one pre-built Piper voice downloaded into `voices/` for testing

**Dependencies:** Phase 1 (host and DI container)

**Done when:** `GET /api/voices` lists available models. Synthesizing a test string produces audible speech through the default audio device. Missing voice falls back to default with logged warning.
<!-- END_PHASE_2 -->

<!-- START_PHASE_3 -->
### Phase 3: Speech Queue and HTTP Speak Endpoint

**Goal:** HTTP clients can POST text to be spoken with per-source voice mapping and priority queuing.

**Components:**
- `SpeechQueue` service — priority queue (lower number = higher priority), serial processing, max depth with eviction, optional interrupt-on-higher-priority
- `POST /api/speak` endpoint — accepts `{ text, source?, voice? }`, resolves voice from source config or explicit override, applies regex filters, queues for speech
- `POST /api/stop` endpoint — cancels current speech and clears queue
- Strongly-typed settings: `SourceSettings` (per-source voice, filters, priority)
- Source filter logic: if `filters` array is non-null, text must match at least one regex pattern

**Dependencies:** Phase 2 (TTS engine and audio output)

**Done when:** POSTing to `/api/speak` with a source plays speech with the configured voice. Filtered text is silently dropped. Priority ordering works correctly. Stop endpoint cancels playback.
<!-- END_PHASE_3 -->

<!-- START_PHASE_4 -->
### Phase 4: Global Hotkeys and Clipboard Capture

**Goal:** User can select text anywhere in Windows and trigger speech via configurable hotkeys.

**Components:**
- `HotkeyService` — Win32 `SetWindowsHookEx` with `WH_KEYBOARD_LL`, configurable key bindings from `Hotkeys` array in config, fires events for each registered hotkey
- `ClipboardService` — saves current clipboard, simulates Ctrl+C via `SendInput`, reads clipboard text, restores original clipboard. STA thread for clipboard access.
- Hotkey direct mode handler — captures text, sends to SpeechQueue with configured voice
- Strongly-typed settings: `HotkeySettings` (array of key + mode + voice)

**Dependencies:** Phase 3 (speech queue)

**Done when:** Pressing a configured hotkey with text selected speaks the text. Clipboard is preserved. Multiple hotkeys with different voices work independently.
<!-- END_PHASE_4 -->

<!-- START_PHASE_5 -->
### Phase 5: Voice Picker Popup

**Goal:** Hotkeys configured in picker mode show a voice selection popup before speaking.

**Components:**
- `VoicePickerForm` — compact, borderless WinForms window. Lists available voices from VoiceManager. Pre-selects last-used voice (persisted in config). Positioned near cursor. Dismisses on Escape, click-away, or selection.
- Picker mode handler in hotkey flow — after clipboard capture, shows VoicePickerForm on STA thread, waits for selection, sends to SpeechQueue
- Last-used voice persistence in `appsettings.json` or separate user preferences file

**Dependencies:** Phase 4 (hotkey infrastructure and clipboard capture)

**Done when:** Picker-mode hotkey shows popup with voice list, selecting a voice speaks the text, popup dismisses correctly on all exit paths (selection, Escape, click-away). Last-used voice is remembered across sessions.
<!-- END_PHASE_5 -->

<!-- START_PHASE_6 -->
### Phase 6: Speak-Selection Endpoint and Stream Deck Plugin

**Goal:** Stream Deck (and other external tools) can trigger speak-selected-text via HTTP.

**Components:**
- `POST /api/speak-selection` endpoint — service performs clipboard capture internally via ClipboardService, queues text for speech
- Stream Deck plugin (JavaScript, SDK 6.x):
  - `SpeakSelection` action — POSTs to `/api/speak-selection`
  - `SpeakText` action — POSTs static text to `/api/speak`
  - `StopSpeaking` action — POSTs to `/api/stop`
  - Settings UI populates voice dropdown from `GET /api/voices`
- Plugin packaging for Elgato distribution format

**Dependencies:** Phase 4 (clipboard service), Phase 3 (HTTP endpoints)

**Done when:** Stream Deck button triggers speech of selected text. Static text button works. Stop button cancels speech. Voice dropdown populates from service.
<!-- END_PHASE_6 -->

<!-- START_PHASE_7 -->
### Phase 7: Documentation and Custom Voice Guide

**Goal:** User-facing documentation for setup, usage, and custom voice import.

**Components:**
- `README.md` — project overview, quick start, configuration reference
- `docs/CUSTOM_VOICES.md` — step-by-step guide for training and importing custom ONNX voices (GPT-SoVITS workflow, Piper fine-tuning workflow, ONNX export, dropping into `voices/`)
- `docs/INTEGRATION.md` — how to integrate other apps with SysTTS HTTP API (request format, source config, filter patterns)
- `CLAUDE.md` — project conventions for Claude Code sessions
- `docs/TECHNICAL_SPEC.md` — architecture, dependencies, configuration reference

**Dependencies:** All previous phases

**Done when:** A new user can follow README to install, configure, and run SysTTS. Custom voice guide covers the full external training workflow. Integration guide has working examples.
<!-- END_PHASE_7 -->

## Additional Considerations

**Audio session:** Since the app runs in user session (not Session 0), audio output works through the default audio device without special configuration. If the user switches audio devices, NAudio's `WaveOutEvent` uses the system default.

**Firewall:** Kestrel bound to `127.0.0.1` only — no firewall prompt on startup. External machines cannot reach the endpoint.

**Concurrent speak requests:** The speech queue serializes all requests. No audio collision. Priority and interrupt behavior are configurable.

**Service not running:** Client apps (T-Tracker, Stream Deck) fail silently when SysTTS is not running. The `.catch(() => {})` pattern in T-Tracker and HTTP timeouts in the Stream Deck plugin handle this gracefully.

**Voice model size:** Piper ONNX models range from ~15MB (low quality) to ~100MB (high quality). The `voices/` directory may grow large. No built-in size management — user manages their own voice collection.
